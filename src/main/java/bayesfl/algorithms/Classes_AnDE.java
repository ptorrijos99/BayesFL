package bayesfl.algorithms;

import bayesfl.data.Data;
import bayesfl.model.Classes;
import bayesfl.model.Model;
import weka.core.Instances;

import java.util.*;

import static org.albacete.simd.utils.Utils.generateCombinations;

/**
 * A local algorithm that extracts the synthetic class values
 * generated by AnDE combinations from a given dataset.
 * <p>
 * This is used for structure discovery only. It builds no classifiers,
 * and instead produces a model with the observed combinations and
 * synthetic class maps (joint attribute + class values).
 * </p>
 */
public class Classes_AnDE implements LocalAlgorithm {

    /**
     * The configuration options, typically containing "-S A[0-9]+DE" or "NB".
     */
    private final String[] options;

    /**
     * Constructor.
     *
     * @param options The algorithm options.
     */
    public Classes_AnDE(String[] options) {
        this.options = Arrays.copyOf(options, options.length);
    }

    /**
     * Build the structure-only model from data.
     *
     * @param data The input data (must be Weka_Instances).
     * @return A model containing the combinations and local class maps.
     */
    @Override
    public Model buildLocalModel(Data data) {
        return buildLocalModel(null, data);
    }

    /**
     * Build the structure-only model, ignoring the input local model.
     *
     * @param localModel Not used.
     * @param data       The input data.
     * @return A structure-only model.
     */
    @Override
    public Model buildLocalModel(Model localModel, Data data) {
        Instances instances = ((bayesfl.data.Weka_Instances) data).getTrain();

        int nAttributes = instances.numAttributes() - 1;
        int nAnDE = getNAnDEFromOptions(options);
        List<int[]> combinations = generateCombinations(nAttributes, nAnDE);

        List<Map<String, Integer>> syntheticClassMaps = new ArrayList<>();
        for (int[] indices : combinations) {
            Map<String, Integer> classMap = extractClassMap(instances, indices);
            syntheticClassMaps.add(classMap);
        }

        return new Classes(combinations, syntheticClassMaps);
    }

    /**
     * Not supported. This algorithm does not support refinement.
     *
     * @param oldModel   Ignored.
     * @param localModel Ignored.
     * @param data       Ignored.
     * @return Throws UnsupportedOperationException.
     */
    @Override
    public Model refinateLocalModel(Model oldModel, Model localModel, Data data) {
        throw new UnsupportedOperationException("Classes_AnDE does not support refinement.");
    }

    /**
     * Gets the name of this algorithm.
     *
     * @return The algorithm name.
     */
    @Override
    public String getAlgorithmName() {
        return "Classes_AnDE";
    }

    /**
     * Gets the name used for refinement (not used).
     *
     * @return Always "None".
     */
    @Override
    public String getRefinementName() {
        return "None";
    }

    /**
     * Extracts the AnDE order (n value) from the -S option.
     *
     * @param options The options passed to the algorithm.
     * @return The integer n value used for AnDE.
     */
    private int getNAnDEFromOptions(String[] options) {
        try {
            String structure = weka.core.Utils.getOption("S", Arrays.copyOf(options, options.length));
            if (structure.startsWith("A") && structure.endsWith("DE")) {
                return Integer.parseInt(structure.substring(1, structure.length() - 2));
            }
        } catch (Exception ignored) {}
        return 0;
    }

    /**
     * Extracts the joint class map for a specific AnDE combination.
     *
     * @param data    The dataset.
     * @param indices The combination of attribute indices.
     * @return A map of joint string values to integer class indices.
     */
    private Map<String, Integer> extractClassMap(Instances data, int[] indices) {
        Map<String, Integer> classMap = new LinkedHashMap<>();
        for (int i = 0; i < data.numInstances(); i++) {
            StringBuilder sb = new StringBuilder();
            for (int idx : indices) sb.append(data.instance(i).stringValue(idx)).append("|||");
            sb.append(data.instance(i).stringValue(data.classIndex()));
            String key = sb.toString();
            classMap.putIfAbsent(key, classMap.size());
        }
        return classMap;
    }
}
